rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthed() {
      return request.auth != null;
    }

    function isAdmin() {
      return request.auth != null && request.auth.token.email == 'eyyup.zaferr.unal@gmail.com';
    }

    function trousseauPath(trousseauId) {
      return /databases/$(database)/documents/trousseaus/$(trousseauId);
    }

    function canReadTrousseau(trousseauId) {
      return exists(trousseauPath(trousseauId)) && (
        get(trousseauPath(trousseauId)).data.ownerId == request.auth.uid ||
        request.auth.uid in get(trousseauPath(trousseauId)).data.get('sharedWith', []) ||
        request.auth.uid in get(trousseauPath(trousseauId)).data.get('editors', [])
      );
    }

    function canWriteTrousseau(trousseauId) {
      return exists(trousseauPath(trousseauId)) && (
        get(trousseauPath(trousseauId)).data.ownerId == request.auth.uid ||
        request.auth.uid in get(trousseauPath(trousseauId)).data.get('editors', [])
      );
    }

    // Users
    match /users/{userId} {
      allow read: if isAuthed();
      allow create, delete: if isAuthed() && request.auth.uid == userId;
      allow update: if isAuthed() && (
        request.auth.uid == userId ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['sharedTrousseauIds']) ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pinnedSharedTrousseauIds'])
      );

      // Invitations (created by owners to invite this user)
      match /trousseauInvitations/{invitationId} {
        // Invited user can read their invitations
        // Owner can also read to check for existing invitations
        allow read: if isAuthed() && (
          request.auth.uid == userId ||
          resource.data.ownerId == request.auth.uid
        );

        // Creation is allowed by anyone who is authenticated (they're creating an invitation for userId)
        // The invitation must have ownerId matching the creator
        allow create: if isAuthed() && request.resource.data.ownerId == request.auth.uid;

        // Deletion allowed by either the invited user (decline) or the owner (cancel)
        allow delete: if isAuthed() && (request.auth.uid == userId || request.auth.uid == resource.data.ownerId);
      }
    }

    // Trousseaus
    match /trousseaus/{trousseauId} {
      // Read directly checks the current document's data via resource
      allow read: if isAuthed() && (
        resource.data.ownerId == request.auth.uid ||
        request.auth.uid in resource.data.get('sharedWith', []) ||
        request.auth.uid in resource.data.get('editors', [])
      );
      allow create: if isAuthed() && request.resource.data.ownerId == request.auth.uid;
      
      // Allow update if:
      // 1. User can write to trousseau (owner or editor), OR
      // 2. User is accepting an invitation (adding themselves to sharedWith/editors)
      allow update: if isAuthed() && (
        canWriteTrousseau(trousseauId) ||
        (
          // User is adding themselves to sharedWith or editors array (invitation acceptance)
          (
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['sharedWith', 'editors', 'updatedAt']) ||
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['sharedWith', 'updatedAt']) ||
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['editors', 'updatedAt'])
          ) &&
          (
            (request.auth.uid in request.resource.data.get('sharedWith', []) && 
             !(request.auth.uid in resource.data.get('sharedWith', []))) ||
            (request.auth.uid in request.resource.data.get('editors', []) && 
             !(request.auth.uid in resource.data.get('editors', [])))
          )
        )
      );
      
      allow delete: if isAuthed() && get(trousseauPath(trousseauId)).data.ownerId == request.auth.uid;

      // Subcollection: categories
      match /categories/{categoryId} {
        // Read categories if user can read the parent trousseau
        // Use direct parent document access instead of exists() to avoid issues
        allow read: if isAuthed() && (
          get(/databases/$(database)/documents/trousseaus/$(trousseauId)).data.ownerId == request.auth.uid ||
          request.auth.uid in get(/databases/$(database)/documents/trousseaus/$(trousseauId)).data.get('sharedWith', []) ||
          request.auth.uid in get(/databases/$(database)/documents/trousseaus/$(trousseauId)).data.get('editors', [])
        );
        allow create, update, delete: if isAuthed() && canWriteTrousseau(trousseauId);
      }

      // Subcollection: products
      match /products/{productId} {
        // Read products if user can read the parent trousseau
        allow read: if isAuthed() && (
          get(/databases/$(database)/documents/trousseaus/$(trousseauId)).data.ownerId == request.auth.uid ||
          request.auth.uid in get(/databases/$(database)/documents/trousseaus/$(trousseauId)).data.get('sharedWith', []) ||
          request.auth.uid in get(/databases/$(database)/documents/trousseaus/$(trousseauId)).data.get('editors', [])
        );
        allow create, update, delete: if isAuthed() && canWriteTrousseau(trousseauId);
      }
    }

    // Products (kept permissive for now, as in current project rules)
    match /products/{productId} {
      allow read, write: if isAuthed();
    }

    // App Versions - Public read for version checking
    match /app_versions/{versionId} {
      allow read: if true; // Everyone can check for updates
      allow write: if isAdmin(); // Only admin can update
    }

    // Feedback - Users can submit and read their own feedback
    match /feedback/{feedbackId} {
      allow create: if isAuthed();
      // Users can read their own feedback, admin can read all
      allow read: if isAuthed() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      // Admin can update to add replies
      // When admin fills adminReply, repliedAt and repliedBy should be set
      allow update: if isAdmin() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['adminReply', 'repliedAt', 'repliedBy']) &&
        (
          // If adminReply is being set (not null), ensure repliedAt and repliedBy are also set
          (request.resource.data.adminReply != null &&
           request.resource.data.repliedAt != null &&
           request.resource.data.repliedBy != null) ||
          // Or if adminReply is being cleared, allow clearing all fields
          (request.resource.data.adminReply == null)
        );
      // Admin can delete feedback
      allow delete: if isAdmin();
    }
  }
}
